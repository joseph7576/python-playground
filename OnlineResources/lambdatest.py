# from: https://realpython.com/python-lambda/
# more in depth: https://en.wikipedia.org/wiki/Lambda_calculus

'''
The identity function, a function that returns its argument

>>> def identity(x):
...     return x
'''

(lambda x: x + 1)(2) # Immediately Invoked Function Expression (IIFE, pronounce “iffy”)

add_two = lambda x: x + 2

print(add_two(3))


''' these are same, may be used interchangeably 
- Anonymous functions
- Lambda functions
- Lambda expressions
- Lambda abstractions
- Lambda form
- Function literals
'''

'''
Note: In the interactive interpreter, the single underscore (_) is bound to the last expression evaluated.
In the example above, the _ points to the lambda function. For more details about the usage of this special character in Python, 
check out The Meaning of Underscores in Python.
'''

'''
Unlike lambda forms in other languages, where they add functionality, 
Python lambdas are only a shorthand notation if you’re too lazy to define a function. :D

https://en.wikipedia.org/wiki/Syntactic_sugar
''' 

# The dis module exposes functions to analyze Python bytecode generated by the Python compiler:
import dis

add = lambda x,y: x + y

print(type(add))

print(dis.dis(add))

''' lambda characteristic
- It can only contain expressions and can’t include statements in its body.
- It is written as a single line of execution.
- It does not support type annotations.
- It can be immediately invoked (IIFE).
'''

'''lambda arugments support
- Positional arguments
- Named arguments (sometimes called keyword arguments)
- Variable list of arguments (often referred to as varargs)
- Variable list of keyword arguments
- Keyword-only arguments
'''

# Defining a decorator -> trace decorator
def trace(f):
    def wrap(*args, **kwargs):
        print(f"[TRACE] func: {f.__name__}, args: {args}, kwargs: {kwargs}")
        return f(*args, **kwargs)

    return wrap

print((trace(lambda x: x ** 2))(3))

import unittest

addtwo = lambda x: x + 2

class LambdaTest(unittest.TestCase):
    def test_add_two(self):
        self.assertEqual(addtwo(2), 4)

    def test_add_two_point_two(self):
        self.assertEqual(addtwo(2.2), 4.2)

    def test_add_three(self):
        # Should fail
        self.assertEqual(addtwo(3), 6)

# if __name__ == '__main__':
#     unittest.main(verbosity=2)
    

addtwo = lambda x: x + 2
addtwo.__doc__ = """Add 2 to a number.
    >>> addtwo(2)
    4
    >>> addtwo(2.2)
    4.2
    >>> addtwo(3) # Should fail
    6
    """

import doctest

if __name__ == '__main__':
    pass
    # unittest.main(verbosity=2)
    # doctest.testmod(verbose=True)
    
'''Flaw:
- It doesn’t follow the Python style guide (PEP 8)
- It’s cumbersome and difficult to read.
- It’s unnecessarily clever at the cost of difficult readability.
'''

'''classic functinoal construct
>>> list(map(lambda x: x.upper(), ['cat', 'dog', 'cow']))
['CAT', 'DOG', 'COW']

>>> list(filter(lambda x: 'o' in x, ['cat', 'dog', 'cow']))
['dog', 'cow']

>>> from functools import reduce
>>> reduce(lambda acc, x: f'{acc} | {x}', ['cat', 'dog', 'cow'])
'cat | dog | cow'
'''

'''use as in key argument
- sort(): list method
- sorted(), min(), max(): built-in functions
- nlargest() and nsmallest(): in the Heap queue algorithm module heapq
'''


# monkey patching
from contextlib import contextmanager
import secrets

def gen_token_one():
    """Generate a random token."""
    return f'TOKEN_{secrets.token_hex(8)}'

@contextmanager
def mock_token():
    """Context manager to monkey patch the secrets.token_hex
    function during testing.
    """
    default_token_hex = secrets.token_hex
    secrets.token_hex = lambda _: 'feedfacecafebeef'
    yield
    secrets.token_hex = default_token_hex

def test_gen_key_one():
    """Test the random token."""
    with mock_token():
        assert gen_token_one() == f"TOKEN_{'feedfacecafebeef'}"

test_gen_key_one()

def gen_token():
    return f'TOKEN_{secrets.token_hex(8)}'

def test_gen_key(monkeypatch):
    monkeypatch.setattr('secrets.token_hex', lambda _: 'feedfacecafebeef')
    assert gen_token() == f"TOKEN_{'feedfacecafebeef'}"
    
''' these two are same
>>> list(map(lambda x: x.capitalize(), ['cat', 'dog', 'cow']))
['Cat', 'Dog', 'Cow']

>>> [x.capitalize() for x in ['cat', 'dog', 'cow']]
['Cat', 'Dog', 'Cow']
'''

'''
Note: The Python programming language, named after Monty Python, 
prefers to use spam, ham, and eggs as metasyntactic variables, instead of the traditional foo, bar, and baz. :D
'''